When given a problem: 
1. Listen - To EVERYTHING - The devil is in the details - you will probably need it all to come up with an optimal solution. 
2. Example - get examples - look for edge cases etc. 
3. Brute Force - get a brute force as early as we can - state the naive solution - and then comment on the run time, and then optimize from there
4. Optimize - Walk through the BUD optimizations - see below - find any cases that our solution does not solve. Time vs Space trade-off. 
5. Walk through - go through our approach in detail
6. Implement - write on the board what the solution is. 
7. Test - go through all cases, especially ones that cause our solution to stop working. 

#### BUD
Bottlenecks
Unnecessary Work
Duplicated Work

Use a new Example, unclog the mind in order to see new things. 

Unused information - anything in the problem that we didn't use, usually we have to use everything in order to come up with an optimal solution. 

Incorrect solution - might help us find an optimal one. 

Time vs Space Trade-off 

Precomputation - is there a way to precompute any of the items so that we can save time later on - eg. sorting - Quick Sort (O (n log n)). 

Hash Tables - they always crop up - can be super useful to us. 

Run time - always end with the rough amount of run time that we might be using here. 

Then we write code on the board - making sure that we modularize as we go - if there is a function that we need but don't have yet, let's imagine that we will create it as we go along. 






