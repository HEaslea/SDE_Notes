Sometimes we don't know how many parameters that a function will require. 
We might want to write a routine to print error messages generated by a program. 

(routine not returning anything). 

A single function, to print them. 
Different calls to our error-printing function might not pas the same arguments, corresponding to different kinds of error messages. 

Two ways of doing it: 


1. If all the arguments have the same type, we can pass a library type named `initializer_list`. 
2. If the types vary, we can write a special function, known as a variadic template, which will be covered must later on lol


`initializer_list` Parameters

When we write a function with unknown arguments of a single type, by using an initializer list parameter. 
It's a library type representing an array of values of a specified type. 

This type is defined in the header. 

The operations that we can use here are: 
![[Pasted image 20240222162521.png]]

Again we must specify the elements that are to be going into this list. 

```
initializer_list<string> ls; 
initializer_list<int> li; 
```

However, all the elements in this list are `const`, there is no way of changing the value of an element in a list like this. 

So if we wanted to write that function, to produce a bunch of error messages from various arguments: 

```
void error_msg(initializer_list<string> il){
    for (auto beg = il.begin(); beg != il.end(); ++beg){
        cout << *beg << "";
    }
    cout << endl;
}
```
The begin and end are analogous to that of the vector functions. 

When we pass a sequence of values to an `initializer_list` parameter, we must enclose the sequence in curly braces, like we would with an initializing list (woah crazy). 
```
if (expected!= actual){ 
	error_msg({"Function X", expected, actual})
}
```


It's sort of like passing a list to a function in python. 

```
void printFromList(initializer_list<string> sl){ 
	for(auto beg = sl.begin(); beg != sl.end(); ++beg){ 
		cout << *beg << "    ";
	}
	cout << endl;
}


int main(){ 
	printFromList({"Hello, "World"});
	printFromList({"How", "Are", "You"});
}
```
Both will print. 

You can also just do: 
```
for(auto str : sl){ 
	cout << str << endl;
	}
```
That works too. 

#### Ellipsis Parameters
We can also use the C library facility called `varargs`. 
Generally, an ellipsis parameter should not be used for anything else. 

Here is an example: 

```
#include <cstdarg> 


double Average(int count,  ...){
	// va_list found in <cstdarg>
	va_list list; 
	va_start(list, count); 
	double avg = 0.0; 
	for (int i = 0; i < count ; i++){ 
		avg += static_cast<double>(va_arg(list, int));
	}

	va_end(list); // ending the use of va_list;

	return avg;
}


int main(){ 
		double avg = average(6, 1, 2, 3, 4, 5, 6);
}
```

`va_list` is a type used to access the values in the ellipsis. This is easier to understand if you think of the ellipsis, where `va_list` will act as an iterator. 
The `va_list` is not a special type, it is a macro definition. 
`va_start` will point to the va_list at the starting point of the ellipsis . 
Taking two arguments, `va_list` and  the last normal parameter. 
`va_arg` returns the value to which `va_list` is currently referring to and also moves `va_list` to the next parameter. 
It will also take two arguments; `va_list` again and the type of the parameter we are trying to access. 
`va_end` only takes on argument; `va_list` again, it will be used to clean up the va_list macro. 

