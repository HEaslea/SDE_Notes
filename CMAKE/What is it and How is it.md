When we have C++ code, then we need to compile it, into a exe ,CMake don't come with one, therefore we need to give it one. 
When we only have one file, this is all really easy, however, what if we have like 100000000000 files, well then we need something that will do it for us. 
CMake is that thing, where we write a script that will go through the source, check if we need to compile those files or not. 
Then we need to make sure that we have the right arguments that we would pass to the compiler for every single file as well. 
Then we need to know how to link all these files together. 
CMake has to be able to do all these things in order: 
- Compiling executables and libraries
- Managing dependencies
- Testing 
- Installing
- Packaging
- Producing documentation
- Testing some more (whatever the fuck this means)

The idea that it is cross platform is amazing too. 

#### How it do
CMake doesn't build anything on its ones. 
It relies on some other tools, however it does orchestrate how all of those other tools will work with each other. 
It knows what steps need to be done, and in what order, and will orchestrate that for us. 

##### The Three Stages
- Configuration
- Generation
- Building

##### Configuring
Reading project details, stored in the **source tree**, and preparing the output, the **build tree**. 

Will check `CMakeCache.txt` if there is one, if this is the first run, it will create an empty build tree and collects all of the details about the environment it's working in eg. what the architecture is, what compilers it can use, what linkers and archivers are installed. 
The `CMakeLists.txt` project configuration file is parsed and executed, using CMake's own language. 
It will explain to CMake the project structure, its targets, and its dependencies. 
The `CMakeCache` will be used to store more stable information. During the parsing of the `CMakeLists.txt`, CMake will grab more information, system details, project configuratins, logs and temp files, which are used for the next step (eg. path to compilers, and other tools). 
It will save this info in order to run it immediately next time. 

##### Generation
After reading project configuration files, CMake will generate a **build system**, for the exact environment that we are working in. 

These **build systems** are just cut to size configuration files for other build systems eg. MakeFile for GNU make, or Ninja and IDE project files for visual studio. 

This stage will be done automatically after the build phase. 

##### Building
Actually using the build system that we have. We have to run the appropriate build tool, which can be done through an IDE or automatically. 
In order to get the target artefacts (referring to files or outputs generated by the build), these are libraries (shared libs(dynamic) `.dll`s or static libs `.lib`), executables, intermediate files such as `.o` files (`.obj`), Auxiliary files (`.pdb`, debug symbols on windows, `.map` memory maps), or just artefacts that we have chosen to create as well. 
The idea here is that we compile -> link -> test -> package. 

##### Single Simple File
```
// CMAKELISTS.TXT
cmake_minimum_required(VERSION 3.26)
project(Hello)
add_executable(Hello hello.cpp)
```

Then we can write ;
```
cmake -B <build tree>
cmake --build <build tree>
```
`<build tree>` placeholder that should be replaced with a path to a temporary directory that will hold the generated files. 

Here, cmake will begin to build our build system, collecting the right compiler that we want to use, then it will write that into the build path. 
Then, it will automatically build the project into that file. 


### Docker
Is a fantastic tool in order to create working virtualized environments, from images to container. 

### The Command Line
CMake is a family of tools and consists of five executables: 
##### CMAKE
- Generating a project buildsystem 
- Building a project
- Installing a project
- Running a script
- Running a command-line tool
- Running a workflow preset 
- Getting help (for me, yes)

##### Generating a Project Buildsystem
In order to build our project, we need a buildsystem. 
The three forms of doing this in CMake: 
```
cmake [<options>] -S <source tree> -B <build tree>
cmake [<options>] <source tree> 
cmake [<options>] <build tree>
```
The top line being preferred, being verbose in CMake is half the battle. 

`cmake -S ./project -B ./build`. 
This will take from project, do all it needs to, and put into build (they're both directories). 


#### Generators
The generator will specify the build system that CMake should produce for your project. Determining the type of project files and build commands CMake will generate to compile and link. 
Windows, might use the Visual Studio Generator, on Unix, we might use Makefiles or Ninja. 

`cmake -G "Visual Studio 16 2019"` might be a good example. 
If we don't specify, then CMake will generate based on the operating system. 
This is something that will be put in `CMakeCache`. 
##### Toolset and Toolchain
Referring to different parts of the configuration that affect how code is compiled and linked. 
**Toolset** - specifying which specific compiler or set of compiler tools should be used within the chosen generator environment, especially when there are multiple compilers available. 
Most commonly used with Visual Studio, where there are multiple version of the MSVC compiler, which could be installed on the same system: 
`cmake -G "Visual Studio 16 2019" -T "v192"` 
IF YOU HAVE Visual Studio 2019, however, if you want to use older compiler toolsets, then we can write: `v141`, which is from VS2017. 
It can define, linkers and other auxiliary tools as well, depending on what is available within that compiler suite. 

**Toolchain** - CMake defines the entire set of tools used to compile, link and build your project. 
These are very important when we are writing for cross platform stuff, like writing for a console.
Imagine we are building on windows machine, but for a linux target. 
Or if we are on x86, which we are, and we want to build for ARM devices. 

In order to define these toolchains, if we were cross compiling for ARM platforms: 
We have to write a `toolchain.cmake`
```
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR arm)

set(CMAKE_C_COMPILER /path/to/arm-gcc)
set(CMAKE_CXX_COMPILER /path/to/arm-g++)
```
Then we will write something like this: 
`cmake -DCMAKE_TOOLCHAIN_FILE=/path/to/toolchain.cmake ..`
With lines like this, we are slowly configuring the build system. 
These are configuration commands, each time we run a command like this: we are setting options and variables that affect the way that CMake configures your project. 

Say we have initial configuration: 
`cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=path/to/toolchain.cmake ..`

Then we refine configuration:
`cmake -DCMAKE_BUILD_TYPE=Debug ..`

Once all our settings are in place, CMake generates the final build files based on your specified configurations. 
Then finally compiling your projects: 
`cmake --build`. 

```
cmake   -G <generator name> 
		-T <toolset spec>
		-A <platform name>
		-S <source tree> -B <build tree>
```

This will configure a number of things. 
Then start the ball rolling with `cmake --build` in order to get it going. 

`cmake --build path/to/build` if we haven't configured the build path, I think this will overwrite. 

#### Manage the Project Cache
CMake queries the system for all kinds of information during the configuration stage. 
This can take some time, this collected information is cached in the `CMakeCache`, found in the build tree directory. 
We can interact with the cache a little more conveniently: 
`cmake -C <initial cache script> -S <source tree> -B <build tree>`
This will prepopulate cached information. 
We can provide a path to CMake listfile, which really only contains a list of set() commands to specify variables. That file will specify how a project will be built. 
![[Pasted image 20241113030416.png]]![[Pasted image 20241113030429.png]]
We can initialize and modify existing cache variables can be done in another way. 
Like so: 
`cmake -D <var>[:<type>]=<value> -S <source tree> -B <build tree>`
The type area is optional. 
A very important variable that we can change is that of BUILD TYPE `(CMAKE_BUILD_TYPE)`: 
The build configuration (Debug, Release etc. )
This should usually, for most generators, be produced during the configuration stage: 
`cmake -S . -B ../build -D CMAKE_BUILD_TYPE=Release`
Some generators will do this configuration during the build phase (the last phase). 
We can list cache variables with the `-L` variable. 

Removing variables can be done with the following option: 
`cmake -U <globbin_expr> -S etc.etc.`

Globbing expressions will be `*` and `?`

### Debugging and Tracing 
`cmake --system-information [file]`
This will give detailed reports of the system's configuration, that will be used during the build process. 
The output will be in the form of a text file. If we want to put it in a file: 
`cmake --system-information system_info.txt`, rather than it being in the terminal. 

Running it in the build tree, means that we will get extra cache variables as well. 

In the upcoming projects, we will be using `message()` in order to report details of the build process. CMake will filter these by the current log level. 
By default it will be `STATUS`. 
Changing like: `cmake --log-level=<level>` 
`ERROR, WARNING, NOTICE, STATUC, VERBOSE, DEBUG, TRACE`. 

#### Configuring Presets
A way to manage and define consistent configurations for building a project. 
These will be stored in `CMakePrests.json` and `CMakeUserPresets.json`. 
We can store: The build type, toolchain, generators, compilers, platform, flags, and environment variables in there. 

```
{
  "version": 3,
  "cmakeMinimumRequired": {
    "major": 3,
    "minor": 21,
    "patch": 0
  },
  "configurePresets": [
    {
      "name": "linux-x64-debug",
      "hidden": false,
      "generator": "Ninja",
      "toolchainFile": "./toolchains/linux-x64.cmake",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug",
        "CMAKE_CXX_STANDARD": "17"
      }
    },
    {
      "name": "win-x64-release",
      "hidden": false,
      "generator": "Visual Studio 16 2019",
      "toolchainFile": "./toolchains/windows-x64.cmake",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release",
        "CMAKE_CXX_STANDARD": "20"
      }
    }
  ]
}
```
Then we can use these as: 
`cmake --preset=<preset> -S <source tree> -B <build tree>`


##### Cleaning the Build Tree
`cmake --fresh -S <source tree> -B <build tree>`


### Building a Project
When we have the build tree, then we are ready to build, CMake will be able to put all the input files into the build. 
It will also give arguments that are specific to our project. 
I think for the whole thing, the build tree is just the directory and the type of build that we are going to use.
The syntax of this is: 
`cmake --build <build tree> [<options>] [-- <build-tool-options>]`
In most cases: 
`cmake --build <build tree>`

There are other key build parameters that we can supply. 
If we want to pass special parameters, then we do them like this. 

While building we can do a series of things: 

##### Running Parallel Builds
Given a multiprocessing machine, why not make the build faster: 
```
cmake --build <build tree> --parallel [<number of jobs>]
cmake --build <build tree> -j [<number of jobs>]
```

##### Selecting Targets
Every project has one or more parts, called **targets**, they represent buildable units in your project, they are typically executable files, libs, or other output artefacts, creating during the build process. 

Usually we just want to build all targets, however, sometimes we might be interested in skipping some or explicitly building  atarget that was deliberately excluded from normal builds: 
`cmake --build <build tree> --target <target1> --target <target2>`
 A good short hand as well is `-t <target>`, that can be used instead. 

##### Cleaning the Build Tree
Removing all artefacts from the build directory, so everything can be created from scratch later. 
`cmake --build <build tree> -t clean`

##### Configuring the Build Type for Multi-configuration Generators
Pretty simple: 
`cmake --build <build tree> --config <cfg>`

##### Debugging the build Process
When we want to check the logs during a particular build phase: 
`cmake --build <build tree> --verbose`
`cmake --build <build tree> -v`

##### Installing a Project
When artefacts are built, we can install them on the system, usually meaning that we are copying files into the correct directories, installing libraries, or running some custom installation logic from a CMake script: 
The syntax of installation mode is: 
`cmake --install <build tree> [<options>]`
`cmake --install <build tree>`
Like the build, we need a build tree, where we are going to install to;
Here are some install options: 
**Installation Directory**
`cmake --install <build tree> --install-prefix <prefix>`
`cmake --install <build tree> --prefix <prefix>`
This is a path prefix, meaning that we append to the path at the front, another path. 
Apparently this won't work that well on windows, as the paths begin with the drive letter: 

Similarly we can do the configuration of the generator: 
`cmake --isntall <build tree> --config <cfg>`

If we want to split our project into components in order to install them differently. 

To install a single component: 
`cmake --install <build tree> --component <component>`

Then to debug this whole process we can do something like this: 
`cmake --install <build tree> --verbose`
`cmake --install <build tree> -v`

#### Running a Script
CMake is a language; Therefore we can use it for standalone scripting. 
It's also cross platform lol, of course it has to be, but that's useful af. 

```
cmake [{-D <var>=<value>}...] -P <cmake script file>
	[-- <unparsed options>...]
```

#### Running a Command Line Tool
`cmake -E <command> [<options>]` 
These are for helper commands such as: 
```
cmake -E copy <file> <destination> // copies a file to the specified destination
cmake -E remove <file> // deleting a file
cmake -E version
cmake -E cmake_link_script <file> [<commands>] // funs a link script
```

We can put this in a script somewhere as well: 
```
add_custom_command(
	TARGET my_target
	PRE_BUILD
	COMMAND ${CMAKE_COMMAND} -E echo "Preparing to build..."
)

add_custom_command(
	TARGET my_target
	POST_BUILD
	COMMAND ${CMAKE_COMMAND} -E echo "Build Complete!"
)
```


##### WorkFlow presets
We can obviously do a lot with CMake, therefore, instead of entering configurations in every single time, we can use presets. 
They bundle multiple steps into a single action that can be executed with just one command. 
`cmake --workflow --list-presets`
This will take from `C:/Users/easle/CMakePresets.json`
Then we can execute a workflow with the simple: 
`cmake --workflow --preset <name>`

### CTEST
Standardizing the way that tests are run, providing a great way to run tests all through one tool: 
```
ctest
Test project /tmp/build
Guessing configuration build
	Start 1: SystemInformationNew
1/1 Test 1: SystemInformationNew ........ Pass 3.19 sec
100% tests passed, 0 tests failed out of 1
Total Test Time(real) = 3.24 sec
```

### CPACK
When we are ready to run with the amazing software that we have just created, then we are ready to package it up. 
Most people do love a convenient binary  set up, CPACK will do that for us, giving more powerful options. 
It will create compressed archives, executable installers, wizards, NuGet packages, macOS bundlers, DMG Packages, RPMs, and many many more. 


#### The Source Tree 
Where our project files will live (also called the **project root**) . Containing all the C++ sources, and CMake project files. 
What do we need in that directory: 
- WE NEED A `CMakeLists.txt` configuration file
- The path to this dir will be given by the user with a -S arg of the cmake command when generating a build system. 
- Avoid hardcoding any absolute paths to the source tree in the CMake code. users of this project will definitely store this in another dir. 


#### The Build Tree
CMake will make this directory in the path specified by the use. 
It will store everything that will be created during the build. 
Artefacts of the project, transient configuration, the cache, the build logs, and the output of your native build tool (like GNU make). 
**Build Root** or **Build Tree**

Build config and artefacts will be created here (binary files, exe's and libs, .o files and archives used for final linking), they have to go somewhere, so they go here. 
This should definitely be outside the source directory, so that we are separating out the two, **out of source builds**. 
Specified by `-B` when we are generating a buildsystem. 
This isn't the final destination, lol, as it's recommended that we have an install stage as well, which takes the final artefacts and puts them in the final place in the system. 
This should also remove all the temporary stuff to clean during the process. 
This is the finalization stage. 

### ListFiles
Files that contain CMake language are called **LISTFILES** and can be included one in another with the `include()`, and `find_package()`,  or indirectly `add_subdirectory().` Usually they have a `.cmake` extension. 
##### Project File
This file should be top of the source tree: 
`CMakeLists.txt`, which is a listfile: 
These should contain at least two commands: 
- `cmake_minimum_required(VERSION F<x.xx>)` setting an expected version of CMake
- `project(<name> <OPTIONS>)` naming the project, the name will be saved in `PROJECT_NAME`. 

As our project grows a lot, we might want to separate things out, into smaller units to be configured and reasoned about separately. 
CMake supports this using subdirectories, using their own `CMakeLists.txt`. 
```
myProject/CMakeLists.txt
myProject/api/CMakeLists.txt
myProject/api/api.h
myProject/api/api.cpp
```
A very simple top level listfile might look something like this: 
```
cmake_minimum_required(VERSION 3.26)
project(app)
message("Top Level CMakeLists.txt")
add_subdirectory(api)
```

The main aspects of the project will be handled in the top level statement: managing dependencies, stating the requirements, detecting the environment etc. The `add_subdirectory(api)` will take us to include another `CMakeLists.txt` within the `api` dir. and then we are performing the steps that are found within that file. 

#### Cache File
These are generated from the listfiles and stored in `CMakeCache.txt`, when the configure stage is run for the first time. Will reside in the root of the build tree, and has a fairly simple format. 

pg 31 for this one. 

External section - for us to modify
Internal section - for CMake to modify

Deleting this file, we regenerate and clean that file. 

#### Package Definition File
A big part of any project are the package files that a project will rely on. 
Package authors can use CMake to ship with a configuration file in order to make it more seamless. 

- Config Files contain information regarding how to usethe library binaries, header, ahd helper tools. Sometimes, they expose CMake macros and functions that can be used in your project. 
- These files are named `<PackageName> - config.cmake`
- Use `find_package()` command to include packages. 
Packages are prebuilts that can be found and use in your project. They typically consist of header files, compiled libs, and sometimes configuration files, 

### JSON and YAML
Javascript object notation and Yet Another Markup Language are both used yb cmake. 


#### Preset Files
Advanced configuration files of the projects can be become busy. Instead of having to configure every single time, we can just use a preset file, that will remember these details. 
We can configure workflows, which ties the configure, generate and build steps into a named list of steps to execute. 
These are stored in two files: 
 - `CMakePrests.json` for project  authors to provide official presets
 - `CMakeUserPresets.json` Dedicated to users who want to customize the project configuration to there liking. 
 There is a whole chapter on these bad boys later on. 


### File Based API
Allowing extern tools to query the buildsystem information: paths to generated files, cache entires, toolchains, etc. CMake will provide a file that has all the answers to queries. 

### Configure Log
CMake version 3.26 and beyond will provide a log for more advanced debugging of the configure stage at 
`<build tree>/CMakeFiles/CMakeConfigureLog.yaml`

#### Ignoring Files in Git

VCS : - version control system

The most popular one is Git. 
Whenever we start a new project, we only want to add the necessary files to the repository.
We specify unwanted files in the `.gitignore` file, we might ignore files that are generated, user-specific, or temporary: 
Git will skip them when forming new commits. 
Here's a good example: 
```
CMakeUserPresets.json
# If in source builds are used, exluce their output like so
build_debug/
build_release/

# generated and user files
**/CMakeCache.txt
**/CmakeUserPresets.json
**/CTestTestfile.cmake
**/CPackConfig.cmake
**/cmake_install.cmake
**/install_manifest.txt
**/compile_commands.txt
```
### Discovering Scripts and Modules
CMake is primarily focussed on making artifacts that get consumed by other systems ( such as CI/CD pipelines and test platforms, or deployed to machines or stored in artifact repositories). 
Scripts and modules also use the CMake language: 

#### Scripts
Platform agnostic, comes with many useful commands. 
Scripts written can be bundled with bigger project or completely independent. 

It's a consistent way to do cross platform work: normally we would have to write a bash script for linux, separate batch files or powershell scripts for windows. 
However, we can just have CMake abstract that all away. 
Why introduce another language, when we can just get it done with CMake. 
Then we can just execute scripts : `-P` and with `cmake -P script.cmake`. 

The scripts can be complex, as much as we want. Or just an empty file. 
Still recommended to call the `cmake_minimum_required()`.  This command will note which policies that we will be using. 
Example script: 
```
# An example of a script
cmake_minimum_required(VERSION 3.26.0)
message("Hello World")
file(WRITE Hello.txt "I am writing to a file")
```
There won't be any stages of configuring etc. nor any caches etc, just write and use the script. 


#### Utility Modules
CMake can use external modules in order to enhance functionality. 
They are reusable modules or scripts, providing additional functions, macros, and configurations to make CMake more versatile. 
They allow us to encapsulate common functionality or custom logic, which then easily imports into your CMake project using `include()` or `find_package()`. 
`FindBoost.cmake` or `FindSDL2.cmake` are common CMake utility modules that help locate and configure Boost or SDL2 libraries. 
They are very similar to header files, and reusable codes in libs etc. 
```
// my_functions.h
int add(int a, int b) { return  a + b; } // fine if just included once

// main.cpp
#include "my_functions.h"
int main() { return add(2, 3); }
```
Similar to utility module in CMake: 
```
# MyUtilities.cmake
function(add_common_flags target)
	target_compile_options(${target} PRIVATE -Wall -Wextra) 
endfunction()
```
```
# CMakeLists.txt
include("${CMAKE_SOURCE_DIR}/cmake/MyUtilities.cmake")
add_executable(MyExecutable main.cpp)
add_common_flags(MyExecutable)
```

```
# CMakeLists.txt
cmake_minimum_required(VERSION 3.26.0)
project(ModuleExample)
include(TestBigEndian)
test_big_endian(ITS_BIG_ENDIAN)
if(IS_BIG_ENDIAN)
message("BIG ENDIAN")
else() 
message("LITTLE_ENDIAN")
endif()
```

### Find Modules
CMake provides over 150 find modules that are able to locate those packages if they are installed in the system. 
The find module will then play a game of hide and seek and look where all the places that it would normally to find the installed system. 
If the files are found, then we can build on that file path. 

`FindCURL` searches for the popular client URL library, and will define a system of variables: 
`CURL_FOUND, CURL_INCLUDE, CURL_LIBRARIES, CURL_VERSION_STRING`. 

This will be furthered covered in chapter 9. 

